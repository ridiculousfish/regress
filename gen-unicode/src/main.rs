mod binary_properties;
mod case_folding;
mod general_category_values;
mod scripts;

use codegen::Scope;
use std::{fs::OpenOptions, io::Write};
use ucd_parse::{
    extracted::{DerivedBinaryProperties, DerivedGeneralCategory},
    parse, CaseFold, Codepoints, CoreProperty, DerivedNormalizationProperty, EmojiProperty,
    Property, PropertyValueAlias, Script, ScriptExtension,
};

// Should match unicode.rs.
const CODE_POINT_BITS: u32 = 20;
const LENGTH_BITS: u32 = 32 - CODE_POINT_BITS;

const MAX_CODE_POINT: u32 = (1 << CODE_POINT_BITS) - 1;

// Our length is stored with a bias of -1, so no need to subtract 1.
const MAX_LENGTH: u32 = 1 << LENGTH_BITS;

pub(crate) const UCD_PATH: &str = "/tmp/ucd-15.0.0";

pub(crate) struct GenUnicode {
    pub(crate) scope: Scope,
    pub(crate) scope_tests: Scope,
    pub(crate) case_folds: Vec<CaseFold>,
    pub(crate) property_value_aliases: Vec<PropertyValueAlias>,
    pub(crate) scripts: Vec<Script>,
    pub(crate) script_extensions: Vec<ScriptExtension>,
    pub(crate) derived_general_category: Vec<DerivedGeneralCategory>,
    pub(crate) core_property: Vec<CoreProperty>,
    pub(crate) properties: Vec<Property>,
    pub(crate) emoji_properties: Vec<EmojiProperty>,
    pub(crate) derived_binary_properties: Vec<DerivedBinaryProperties>,
    pub(crate) derived_normalization_properties: Vec<DerivedNormalizationProperty>,
}

fn main() {
    let mut gen = GenUnicode {
        scope: Scope::new(),
        scope_tests: Scope::new(),
        case_folds: parse(UCD_PATH).expect("could not parse CaseFolding.txt"),
        property_value_aliases: parse(UCD_PATH).expect("could not parse PropertyValueAliases.txt"),
        scripts: parse(UCD_PATH).expect("could not parse Scripts.txt"),
        script_extensions: parse(UCD_PATH).expect("could not parse ScriptExtensions.txt"),
        derived_general_category: parse(UCD_PATH)
            .expect("could not parse extracted/DerivedGeneralCategory.txt"),
        core_property: parse(UCD_PATH).expect("could not parse CoreProperties.txt"),
        properties: parse(UCD_PATH).expect("could not parse PropList.txt"),
        emoji_properties: parse(UCD_PATH).expect("could not parse emoji-data.txt"),
        derived_binary_properties: parse(UCD_PATH)
            .expect("could not parse extracted/DerivedBinaryProperties.txt"),
        derived_normalization_properties: parse(UCD_PATH)
            .expect("could not parse DerivedNormalizationProps.txt"),
    };

    let file_unicode_tables_path = "../src/unicodetables.rs";
    let file_tests_path = "../tests/unicode_property_escapes.rs";

    let mut file_unicode_tables = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(file_unicode_tables_path)
        .expect("Failed to open file for unicode tables");

    let mut file_tests = OpenOptions::new()
        .create(true)
        .truncate(true)
        .write(true)
        .open(file_tests_path)
        .expect("Failed to open file for tests");

    file_unicode_tables
        .write_all(b"// DO NOT EDIT! This file is autogenerated from gen-unicode.\n")
        .expect("Failed to write to unicode tables file");

    file_tests
        .write_all(b"// DO NOT EDIT! This file is autogenerated from gen-unicode.\n")
        .expect("Failed to write to tests file");

    gen.scope.import("crate::unicode", "CodePointRange");
    gen.scope.import("crate::unicode", "CodePointRangeUnpacked");
    gen.scope.import("crate::unicode", "FoldRange");

    gen.generate_binary_properties();
    gen.generate_case_folds();
    gen.generate_general_category();
    gen.generate_scripts();

    gen.scope_tests.import("common", "*");
    gen.scope_tests.raw("pub mod common;");

    gen.generate_binary_properties_tests();
    gen.generate_general_category_tests();

    file_unicode_tables
        .write_all(gen.scope.to_string().as_bytes())
        .expect("Failed to write to unicode tables file");

    file_tests
        .write_all(gen.scope_tests.to_string().as_bytes())
        .expect("Failed to write to tests file");

    std::process::Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(file_unicode_tables_path)
        .output()
        .expect("Failed to run 'cargo fmt' on unicode tables file");

    std::process::Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(file_tests_path)
        .output()
        .expect("Failed to run 'cargo fmt' on tests file");
}

// Combine unicode code point ranges, if they are adjacent.
pub(crate) fn pack_adjacent_chars(chars: &mut Vec<(u32, u32)>) {
    let chars_orig = chars.clone();
    let mut chars_iter = chars_orig.iter().cloned().peekable();

    chars.clear();

    while let Some((start, mut end)) = chars_iter.next() {
        while let Some((next_start, next_end)) = chars_iter.peek() {
            if end + 1 == *next_start {
                end = *next_end;
                chars_iter.next();
            } else {
                break;
            }
        }

        chars.push((start, end));
    }
}

// Given a list of inclusive ranges of code points, return a list of strings creating corresponding CodePointRange.
// If a range is too big, it is split into smaller abutting ranges.
pub(crate) fn chars_to_code_point_ranges(chars: &[(u32, u32)]) -> Vec<String> {
    chars
        .iter()
        .flat_map(|p| {
            let (mut start, end) = *p;
            assert!(end >= start, "Range out of order");
            assert!(
                end <= MAX_CODE_POINT,
                "end exceeds bits allocated for code point: {} {}",
                start,
                end //"end exceeds bits allocated for code point"
            );
            let mut res = Vec::new();
            let mut len = end - start + 1;
            while len > 0 {
                let amt = std::cmp::min(len, MAX_LENGTH);
                res.push(format!("CodePointRange::from({}, {}),", start, amt));
                start += amt;
                len -= amt;
            }
            res
        })
        .collect()
}

fn codepoints_to_range(cp: &Codepoints) -> (u32, u32) {
    match cp {
        Codepoints::Single(cp) => (cp.value(), cp.value()),
        Codepoints::Range(range) => (range.start.value(), range.end.value()),
    }
}
