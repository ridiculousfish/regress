mod binary_properties;
mod case_folding;
mod general_category_values;
mod scripts;

use codegen::Scope;
use std::{fs::OpenOptions, io::Write};
use ucd_parse::{parse, PropertyValueAlias, Script, ScriptExtension};

// Should match unicode.rs.
const CODE_POINT_BITS: u32 = 20;
const LENGTH_BITS: u32 = 32 - CODE_POINT_BITS;

const MAX_CODE_POINT: u32 = (1 << CODE_POINT_BITS) - 1;

// Our length is stored with a bias of -1, so no need to subtract 1.
const MAX_LENGTH: u32 = 1 << LENGTH_BITS;

pub(crate) struct GenUnicode {
    pub(crate) scope: Scope,
    pub(crate) scope_tests: Scope,
    pub(crate) property_value_aliases: Vec<PropertyValueAlias>,
    pub(crate) scripts: Vec<Script>,
    pub(crate) script_extensions: Vec<ScriptExtension>,
}

fn main() {
    let ucd_path = "/tmp/ucd-15.0.0";

    let mut gen = GenUnicode {
        scope: Scope::new(),
        scope_tests: Scope::new(),
        property_value_aliases: parse(ucd_path).expect("could not parse PropertyValueAliases.txt"),
        scripts: parse(ucd_path).expect("could not parse Scripts.txt"),
        script_extensions: parse(ucd_path).expect("could not parse ScriptExtensions.txt"),
    };

    let file_unicode_tables_path = "../src/unicodetables.rs";
    let file_tests_path = "../tests/unicode_property_escapes.rs";

    let mut file_unicode_tables = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(file_unicode_tables_path)
        .expect("Failed to open file for unicode tables");

    let mut file_tests = OpenOptions::new()
        .create(true)
        .truncate(true)
        .write(true)
        .open(file_tests_path)
        .expect("Failed to open file for tests");

    file_unicode_tables
        .write_all(b"// DO NOT EDIT! This file is autogenerated from gen-unicode.\n")
        .expect("Failed to write to unicode tables file");

    file_tests
        .write_all(b"// DO NOT EDIT! This file is autogenerated from gen-unicode.\n")
        .expect("Failed to write to tests file");

    gen.scope.import("crate::unicode", "CodePointRange");
    gen.scope.import("crate::unicode", "CodePointRangeUnpacked");
    gen.scope.import("crate::unicode", "FoldRange");

    binary_properties::generate(&mut gen.scope);
    case_folding::generate_folds(&mut gen.scope);
    general_category_values::generate(&mut gen.scope);
    gen.generate_scripts();

    gen.scope_tests.import("common", "*");
    gen.scope_tests.raw("pub mod common;");

    binary_properties::generate_tests(&mut gen.scope_tests);
    general_category_values::generate_tests(&mut gen.scope_tests);

    file_unicode_tables
        .write_all(gen.scope.to_string().as_bytes())
        .expect("Failed to write to unicode tables file");

    file_tests
        .write_all(gen.scope_tests.to_string().as_bytes())
        .expect("Failed to write to tests file");

    std::process::Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(file_unicode_tables_path)
        .output()
        .expect("Failed to run 'cargo fmt' on unicode tables file");

    std::process::Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(file_tests_path)
        .output()
        .expect("Failed to run 'cargo fmt' on tests file");
}

// Parse line from the UCD files with the following syntax:
// 0380..0383    ; Cn #   [4] <reserved-0380>..<reserved-0383>
// 038B          ; Cn #       <reserved-038B>
pub(crate) fn parse_line(line: &str, chars: &mut Vec<(u32, u32)>, property: &str) {
    if line.starts_with('#') {
        return;
    }

    let split_str = format!("; {}", property);
    let mut line_iter = line.split(&split_str);

    if let Some(codepoint_hexes) = line_iter.next() {
        if let Some(rest) = line_iter.next() {
            if !rest.trim_start().starts_with('#') {
                return;
            }
        } else {
            return;
        }

        let mut iter = codepoint_hexes.split("..");
        if let Some(first_hex) = iter.next() {
            if let Some(second_hex) = iter.next() {
                let first_int = u32::from_str_radix(first_hex.trim(), 16).unwrap();
                let second_int = u32::from_str_radix(second_hex.trim(), 16).unwrap();
                chars.push((first_int, second_int));
            } else {
                let i = u32::from_str_radix(first_hex.trim(), 16).unwrap();
                chars.push((i, i))
            }
        }
    }
}

// Combine unicode code point ranges, if they are adjacent.
pub(crate) fn pack_adjacent_chars(chars: &mut Vec<(u32, u32)>) {
    let chars_orig = chars.clone();
    let mut chars_iter = chars_orig.iter().cloned().peekable();

    chars.clear();

    while let Some((start, mut end)) = chars_iter.next() {
        while let Some((next_start, next_end)) = chars_iter.peek() {
            if end + 1 == *next_start {
                end = *next_end;
                chars_iter.next();
            } else {
                break;
            }
        }

        chars.push((start, end));
    }
}

// Given a list of inclusive ranges of code points, return a list of strings creating corresponding CodePointRange.
// If a range is too big, it is split into smaller abutting ranges.
pub(crate) fn chars_to_code_point_ranges(chars: &[(u32, u32)]) -> Vec<String> {
    chars
        .iter()
        .flat_map(|p| {
            let (mut start, end) = *p;
            assert!(end >= start, "Range out of order");
            assert!(
                end <= MAX_CODE_POINT,
                "end exceeds bits allocated for code point: {} {}",
                start,
                end //"end exceeds bits allocated for code point"
            );
            let mut res = Vec::new();
            let mut len = end - start + 1;
            while len > 0 {
                let amt = std::cmp::min(len, MAX_LENGTH);
                res.push(format!("CodePointRange::from({}, {}),", start, amt));
                start += amt;
                len -= amt;
            }
            res
        })
        .collect()
}
