use codegen::Scope;
use std::{fs::OpenOptions, io::Write};
use ucd_parse::{
    extracted::{DerivedBinaryProperties, DerivedGeneralCategory},
    parse, CaseFold, Codepoints, CoreProperty, DerivedNormalizationProperty, EmojiProperty,
    Property, PropertyValueAlias, Script, ScriptExtension, UnicodeData,
};

mod binary_properties;
mod case_folding;
mod general_category_values;
mod scripts;
mod string_properties;
mod uppercase;

// Should match unicode.rs.
const CODE_POINT_BITS: u32 = 20;
const LENGTH_BITS: u32 = 32 - CODE_POINT_BITS;

// Our length is stored with a bias of -1, so no need to subtract 1.
const MAX_LENGTH: u32 = 1 << LENGTH_BITS;

const UCD_PATH: &str = "/tmp/ucd-15.1.0";

pub(crate) struct GenUnicode {
    pub(crate) scope: Scope,
    pub(crate) scope_tests: Scope,
    pub(crate) case_folds: Vec<CaseFold>,
    pub(crate) property_value_aliases: Vec<PropertyValueAlias>,
    pub(crate) scripts: Vec<Script>,
    pub(crate) script_extensions: Vec<ScriptExtension>,
    pub(crate) derived_general_category: Vec<DerivedGeneralCategory>,
    pub(crate) core_property: Vec<CoreProperty>,
    pub(crate) properties: Vec<Property>,
    pub(crate) emoji_properties: Vec<EmojiProperty>,
    pub(crate) derived_binary_properties: Vec<DerivedBinaryProperties>,
    pub(crate) derived_normalization_properties: Vec<DerivedNormalizationProperty>,
    pub(crate) data: Vec<UnicodeData>,
}

fn main() {
    let mut gen = GenUnicode {
        scope: Scope::new(),
        scope_tests: Scope::new(),
        case_folds: parse(UCD_PATH).expect("could not parse CaseFolding.txt"),
        property_value_aliases: parse(UCD_PATH).expect("could not parse PropertyValueAliases.txt"),
        scripts: parse(UCD_PATH).expect("could not parse Scripts.txt"),
        script_extensions: parse(UCD_PATH).expect("could not parse ScriptExtensions.txt"),
        derived_general_category: parse(UCD_PATH)
            .expect("could not parse extracted/DerivedGeneralCategory.txt"),
        core_property: parse(UCD_PATH).expect("could not parse CoreProperties.txt"),
        properties: parse(UCD_PATH).expect("could not parse PropList.txt"),
        emoji_properties: parse(UCD_PATH).expect("could not parse emoji-data.txt"),
        derived_binary_properties: parse(UCD_PATH)
            .expect("could not parse extracted/DerivedBinaryProperties.txt"),
        derived_normalization_properties: parse(UCD_PATH)
            .expect("could not parse DerivedNormalizationProps.txt"),
        data: parse(UCD_PATH).expect("could not parse UnicodeData.txt"),
    };

    let file_unicode_tables_path = "../src/unicodetables.rs";
    let file_tests_path = "../tests/unicode_property_escapes.rs";

    let mut file_unicode_tables = OpenOptions::new()
        .create(true)
        .write(true)
        .truncate(true)
        .open(file_unicode_tables_path)
        .expect("Failed to open file for unicode tables");

    let mut file_tests = OpenOptions::new()
        .create(true)
        .truncate(true)
        .write(true)
        .open(file_tests_path)
        .expect("Failed to open file for tests");

    file_unicode_tables
        .write_all(b"// DO NOT EDIT! This file is autogenerated from gen-unicode.\n")
        .expect("Failed to write to unicode tables file");

    file_tests
        .write_all(b"// DO NOT EDIT! This file is autogenerated from gen-unicode.\n")
        .expect("Failed to write to tests file");

    gen.scope.import("crate::unicode", "FoldRange");
    gen.scope.import("crate::codepointset", "Interval");

    gen.generate_binary_properties();
    gen.generate_case_folds();
    gen.generate_general_category();
    gen.generate_scripts();
    gen.generate_uppercase();
    gen.generate_string_properties();

    gen.scope_tests.import("common", "*");
    gen.scope_tests.raw("pub mod common;");

    gen.generate_binary_properties_tests();
    gen.generate_general_category_tests();

    file_unicode_tables
        .write_all(gen.scope.to_string().as_bytes())
        .expect("Failed to write to unicode tables file");

    file_tests
        .write_all(gen.scope_tests.to_string().as_bytes())
        .expect("Failed to write to tests file");

    std::process::Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(file_unicode_tables_path)
        .output()
        .expect("Failed to run 'cargo fmt' on unicode tables file");

    std::process::Command::new("cargo")
        .arg("fmt")
        .arg("--")
        .arg(file_tests_path)
        .output()
        .expect("Failed to run 'cargo fmt' on tests file");
}

// Combine unicode code point ranges, if they are adjacent.
pub(crate) fn pack_adjacent_codepoints(codepoints: &mut Vec<(u32, u32)>) {
    let codepoints_original = codepoints.clone();
    let mut codepoints_iter = codepoints_original.iter().cloned().peekable();

    codepoints.clear();

    while let Some((start, mut end)) = codepoints_iter.next() {
        while let Some((next_start, next_end)) = codepoints_iter.peek() {
            if (start..=end).contains(next_start) && (start..=end).contains(next_end) {
                codepoints_iter.next();
                continue;
            }

            if end + 1 == *next_start {
                end = *next_end;
                codepoints_iter.next();
            } else {
                break;
            }
        }

        codepoints.push((start, end));
    }
}

// Remove a unicode code point range from the given ranges.
pub(crate) fn remove_codepoints(codepoints: &mut Vec<(u32, u32)>, range: (u32, u32)) {
    let codepoints_original = codepoints.clone();

    codepoints.clear();

    for (start, end) in codepoints_original {
        if start > range.1 || end < range.0 {
            codepoints.push((start, end));
        } else if start < range.0 && end > range.1 {
            codepoints.push((start, range.0 - 1));
            codepoints.push((range.1 + 1, end));
        } else if start < range.0 {
            codepoints.push((start, range.0 - 1));
        } else if end > range.1 {
            codepoints.push((range.1 + 1, end));
        }
    }
}

fn codepoints_to_range(cp: &Codepoints) -> (u32, u32) {
    match cp {
        Codepoints::Single(cp) => (cp.value(), cp.value()),
        Codepoints::Range(range) => (range.start.value(), range.end.value()),
    }
}

type CodePoint = u32;

#[derive(Debug, Copy, Clone)]
pub(crate) struct FoldPair {
    pub(crate) orig: CodePoint,
    pub(crate) folded: CodePoint,
}

impl FoldPair {
    fn delta(self) -> i32 {
        (self.folded as i32) - (self.orig as i32)
    }

    fn stride_to(self, rhs: FoldPair) -> u32 {
        rhs.orig - self.orig
    }
}

pub(crate) struct DeltaBlock {
    /// Folds original -> folded.
    folds: Vec<FoldPair>,
}

impl DeltaBlock {
    pub(crate) fn create(fp: FoldPair) -> DeltaBlock {
        DeltaBlock { folds: vec![fp] }
    }

    pub(crate) fn stride(&self) -> Option<u32> {
        if self.folds.len() >= 2 {
            Some(self.folds[0].stride_to(self.folds[1]))
        } else {
            None
        }
    }

    pub(crate) fn first(&self) -> FoldPair {
        *self.folds.first().unwrap()
    }

    fn last(&self) -> FoldPair {
        *self.folds.last().unwrap()
    }

    pub(crate) fn length(&self) -> usize {
        (self.last().orig as usize) - (self.first().orig as usize) + 1
    }

    pub(crate) fn delta(&self) -> i32 {
        self.first().delta()
    }

    #[allow(clippy::if_same_then_else)]
    pub(crate) fn can_append(&self, fp: FoldPair) -> bool {
        if self.folds.is_empty() {
            // New block.
            true
        } else if fp.orig - self.first().orig > MAX_LENGTH {
            // Length would be too big.
            false
        } else if self.delta() != fp.delta() {
            // Different deltas in this block.
            false
        } else if let Some(stride) = self.stride() {
            // Strides must match and be power of 2.
            stride == self.last().stride_to(fp)
        } else {
            // No stride yet.
            // Stride must be power of 2.
            self.last().stride_to(fp).is_power_of_two()
        }
    }

    pub(crate) fn append(&mut self, fp: FoldPair) {
        std::debug_assert!(self.can_append(fp));
        self.folds.push(fp)
    }
}

/// Format code points
pub(crate) fn format_interval_table(name: &str, codepoints: &[(u32, u32)]) -> String {
    format!(
        "const {}: [Interval; {}] = [{}];",
        name,
        codepoints.len(),
        codepoints
            .iter()
            .map(|(first, last)| format!("Interval::new({}, {}),", first, last))
            .collect::<Vec<String>>()
            .join("")
    )
}
